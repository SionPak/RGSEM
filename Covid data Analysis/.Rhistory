require(dplyr)
temp_table = readxl::read_excel("C:/Users/Sion Park/Documents/카카오톡 받은 파일/여론조사데이터.xlsx")
temp_table = temp_table[ , !(colnames(temp_table)%in% c("c3_9", "c5_1_9","d3_9", "c3_9", "f2_1_9", "f3_9"))]
temp_table = temp_table %>% select(-(1:3))
test_matrix = matrix(0, 31,31)
rownames(test_matrix) = colnames(test_matrix) = colnames(temp_table)
temp_table = apply(temp_table, 2, as.factor)
tt = chisq.test(temp_table[,1],temp_table[,2])
tt$p.value
for(i in 1:31){
for(j in 1:31){
test_matrix[i,j] = chisq.test(temp_table[,i],temp_table[,j])$p.value
}
}
test_matrix = test_matrix[!grepl('9', colnames(temp_table)),!grepl('9', colnames(temp_table))]
test_matrix[test_matrix>0.05]
test_matrix>0.05
test_matrix = test_matrix[nchar(colnames(test_matrix))==2,nchar(colnames(test_matrix))==2]
save(test_matrix, file = "test_matrix.RData")
save(test_matrix, file = "C:/test_matrix.RData")
?chisq.test
test.matrix>0.01
test_matrix>0.01
test_matrix>0.001
test_matrix>0.01
test_matrix<0.01
test_matrix>0.2
test_matrix>0.01
test_matrix>0.001
test_matrix>0.01
test_result = test_matrix>0.01
test_result[lower.tri(test_result)]
test_result[upper.tri(test_result)] = 0
test_result
test_matrix
test_matrix>0.01
test_matrix>0.2
test_matrix>0.01
test_matrix>0.0001
test_matrix>0.00001
test_matrix>0.0000001
test_matrix>0.000000000000000000000000001
test_matrix>0.000000000000000000001
test_matrix>0.000000000001
test_matrix>0.0001
test_matrix<0.0001
(test_matrix<0.0001)[1:4,1:4]
(test_matrix<0.0001)[5:9,5:9]
test_matrix<0.001
colSums(test_matrix< 0.001)
colSums(test_matrix< 0.001)-1
colSums(test_matrix< 0.0001)-1
colSums(test_matrix< 0.00001)-1
colSums(test_matrix< 0.10^(-4))-1
colSums(test_matrix< 0.00001)-1
test_matrix< 0.00001
ttt = test_matrix< 0.00001
ttt[1:4,1:4] = F
ttt[5:9,5:9] =F
ttt[10:12,10:12] =F
ttt[13:14,13:14] =F
ttt[15:17,15:17] =F
ttt[18:19,18:19] =F
tt
ttt
colSums(ttt)
require(dplyr)
temp_table = readxl::read_excel("C:/Users/Sion Park/Documents/카카오톡 받은 파일/여론조사데이터.xlsx")
temp_table = temp_table[ , !(colnames(temp_table)%in% c("c3_9", "c5_1_9","d3_9", "c3_9", "f2_1_9", "f3_9"))]
temp_table = temp_table %>% select(-(1:3))
test_matrix = matrix(0, 31,31)
rownames(test_matrix) = colnames(test_matrix) = colnames(temp_table)
temp_table = apply(temp_table, 2, as.factor)
tt = chisq.test(temp_table[,1],temp_table[,2])
tt$p.value
for(i in 1:31){
for(j in 1:31){
test_matrix[i,j] = chisq.test(temp_table[,i],temp_table[,j])$p.value
}
}
test_matrix = test_matrix[!grepl('9', colnames(temp_table)),!grepl('9', colnames(temp_table))]
test_matrix[test_matrix>0.05]
test_matrix>0.05
test_matrix = test_matrix[nchar(colnames(test_matrix))==2,nchar(colnames(test_matrix))==2]
test_matrix>0.2
colSums(test_matrix>0.2)
test_list = list()
test_list$b = test_matrix[1:4,1:4]
test_list$c = test_matrix[5:9,5:9]
test_list$d = test_matrix[10:12,10:12]
test_list$e = test_matrix[13:14,13:14]
test_list$f = test_matrix[15:17,15:17]
test_list$g = test_matrix[18:19,18:19]
test_list
save(test_list , file = 'C:/test_list.Rdata')
Forward_Learning_fun_out = function(X, max_degree = 1,C = NULL, method = 'Cols1') {
require(MASS)
X = as.matrix(X)
p = ncol(X) ;   n = nrow(X)
Ordering = rep(0, p) ; RemNodes = 1:p
k = 1
valid_list = list()
score_valid_sample_temp = sapply(RemNodes,
function(i) score_valid_sample_fun(X,i,1,C = C,valid_set = 1:n , method = method))
Ordering[k] = which.min(unlist(score_valid_sample_temp[1,]))
valid_list[[k]] =score_valid_sample_temp[2,][[Ordering[k] ]]
RemNodes = setdiff(RemNodes, Ordering)
while( length(RemNodes) > 1 ) {
k = k + 1 ; Z = NULL
for(l in Ordering[1:k-1] ){
Z = cbind(Z, poly( X[,l], degree = max_degree, raw = T) )
}
score_valid_sample_temp = sapply(RemNodes,
function(j) score_valid_sample_fun(X,j,Z,C= C,
valid_set = valid_list[[k-1]], method = method))
scores = unlist(score_valid_sample_temp[1,])
Ordering_j = sample(which( scores == min(scores) ),1)
valid_list[[k]] =score_valid_sample_temp[2,][[Ordering_j]]
Ordering[k] = RemNodes[Ordering_j]
RemNodes = setdiff(RemNodes, Ordering)
}
Ordering[p] = RemNodes
Z = NULL
for(l in Ordering[1:p-1] ){
Z = cbind(Z, poly( X[,l], degree = max_degree, raw = T) )
}
score_valid_sample_temp =score_valid_sample_fun(X , j = RemNodes , Z ,C ,valid_set = valid_list[[p-1]], method = method )
valid_list[[p]] = score_valid_sample_temp[[2]]
return( list(Ordering, valid_list ))
}
GSEM_Algorithm = function(data, method, alpha = 0.001,  direction ="forward", graph = NULL,
max_degree = 1 , C=NULL){
set.seed(1)
library(bnlearn)
###################
X = as.matrix( data )
p = ncol(X)
n = nrow(X)
RemNode = 1:p
pi_GSEM = NULL
Estimated_G = Estimated_O = matrix(0, p ,p)
evaluation_result_GSEM = evaluation_result_GSEM_MEC = evaluation_result_GSEM_Oracle = NULL
####
Runtime = proc.time()[3]
#### Step 1): Finding the Ordering ####
result = Forward_Learning_fun_out(X, max_degree = max_degree,C, method = method)
Ordering = result[[1]]
valid_obs = result[[2]]
#### Step 2): Finding the Parents ####
used_ci_test = "zf"
#used_ci_test = "smc-zf"
#used_ci_test = "mi-g"
#used_ci_test = "smc-mi-g"
#used_ci_test = "cor"
####### Cook's
for(m in 2:p){
j = Ordering[m]
for(k in Ordering[1:(m-1)]){
if(m > 2){
S = setdiff( Ordering[ 1:(m-1)], k )
valid_idx = Reduce(intersect,valid_obs[Ordering[1:m]])
parent_pvalue = ci.test(X[valid_idx, j], X[valid_idx, k], X[valid_idx, S], test = used_ci_test)$p.value
}else{
valid_idx = Reduce(intersect,valid_obs[Ordering[1:m]])
parent_pvalue = ci.test(X[valid_idx, j], X[valid_idx, k], test = used_ci_test)$p.value
}
if(parent_pvalue < alpha){
Estimated_G[j, k] = 1
}
}
}
####
Runtime = proc.time()[3] - Runtime
#print(paste("It takes: ", Runtime))
Estimated_G = matrix(Estimated_G, ncol = p)
####
est_MEC = dag2cpdagAdj(Estimated_G)
####
if( !is.null(graph) ){
B = graph
B[B!=0] =1
MEC = B + t(B)
Oracle_DAG = estimated_graph_fun( MEC, Ordering)
evaluation_result_GSEM = evaluation_fun( B, Estimated_G )
evaluation_result_GSEM_MEC = evaluation_fun( dag2cpdagAdj(B), est_MEC)
evaluation_result_GSEM_Oracle = evaluation_fun( B, Oracle_DAG )
}
return(
list( DAG_Evaluation = evaluation_result_GSEM,
MEC_Evaluation = evaluation_result_GSEM_MEC,
Oracle_Evaluation = evaluation_result_GSEM_Oracle,
DAG = Estimated_G,
Ordering = Ordering,
Time = Runtime)
)
}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source('../Evaluation.R')
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source('../Evaluation.R')
source('../Forward_Learning_with_outlier.R')
source('../RGSEM_algorithm.R')
require(tidyverse)
require(ggmap)
require(reshape2)
require(glmnet)
require(maptools)
require(data.table)
library("sp")
library("maptools")
korea_map_shp = readShapePoly('SHP/KR.shp')
korea_map = fortify(korea_map_shp)
library("accelerometry")
korea_map_shp = readShapePoly('SHP/KR.shp')
korea_map = fortify(korea_map_shp)
Region_all = fread("Korea.csv",encoding = 'UTF-8')
covid = read.csv("covid_KR.csv")
covid = t(covid)
date_idx =row.names(covid)[-1]
date_idx = as.Date(paste0(substr(date_idx,2,5),'-' ,substr(date_idx,8,9),'-' ,substr(date_idx,12,13)))
covid[covid=='-']= 0
colnames(covid) = covid[1,] ; covid = covid[-1,] ;  covid = apply(covid,2, as.numeric)
covid_view = cbind(as.Date(date_idx),as.data.frame(covid))
# View(covid_view)
covid[covid<0]= 0
row.names(covid)= date_idx
covid_raw = covid
library("accelerometry")
roll = 3
for(j in 2:ncol(covid)){
covid[roll:nrow(covid) ,j] = movingaves(covid[,j], window = roll)
}
covid = covid[-(1: (roll-1) ),]
date_idx = date_idx[c(-1,-length(date_idx))]
covid_korea = function(date_idx_for_analysis= date_idx_for_analysis ,alpha , C,restricted_infection, method,tikzedge = F){
covid_for_analysis = covid[date_idx_for_analysis,]
valid_region_idx = (colSums(covid_for_analysis)>restricted_infection)
for(j in 1:ncol(covid_for_analysis)){
covid_for_analysis[,j] = covid_for_analysis[,j]/sum(covid_for_analysis[,j])
}
Region = Region_all[valid_region_idx,]
Region$address = as.character(Region$address)
covid_for_analysis = covid_for_analysis[,valid_region_idx]
covid_for_analysis[covid_for_analysis<0] = 0
###### Proposed#############
if(sum(colnames(covid_for_analysis) == Region$address) != ncol(covid_for_analysis)){
message("correct name of regions required.");
}
X =  covid_for_analysis
# covid_new_temp  = covid_new_temp*100
DAG_covid = GSEM_Algorithm(data = X, method = method, alpha = alpha, C = C)
print(colnames(X)[DAG_covid$Ordering])
DAG = DAG_covid$DAG#DAG=Ordering_covid$DAG
DAG = as.data.frame(DAG)
colnames(DAG) = rownames(DAG) = Region$address
DAG = cbind(rownames(DAG), DAG) ; colnames(DAG)[1] = 'Address'
direction = melt(DAG,id.vars = 'Address') %>% filter(value ==1) %>% dplyr::select(c(1,2))
colnames(direction) = c('To', 'From')
direction$From = as.character(direction$From);direction$To = as.character(direction$To)
direction= direction %>% left_join(Region, by = c('To' = 'address' ))
colnames(direction)[3:4] = c('To_Y', 'To_X')
direction = direction %>% left_join(Region, by = c('From' = 'address' ))
colnames(direction)[5:6] = c('From_Y', 'From_X')
if(tikzedge == T){
temp = direction[order(direction$From),c(2,1) ]
temp2 = paste0("\\draw [edge] (",temp[,1],') -- (', temp[,2],"); \n")
for(i in 1:length(temp2)){
cat(temp2[i])
}
}
q= ggplot() +
geom_polygon(data = korea_map, aes(x = long, y = lat, group = group), fill = "#FFFFFF", colour = "#000000")+
geom_segment(data = direction, aes(x = From_X, y= From_Y, xend = To_X, yend = To_Y, color= From),
arrow = arrow(length = unit(0.2,'cm'),type = 'closed', angle = 20) , size = 0.8)+
geom_text(data= Region_all[valid_region_idx,] ,aes(x = Longitude, y= Latitude+0.1, label = address))+
coord_fixed(ratio=1)
return(q)
}
covid = read.csv("covid_KR.csv")
covid = t(covid)
date_idx =row.names(covid)[-1]
date_idx = as.Date(paste0(substr(date_idx,2,5),'-' ,substr(date_idx,8,9),'-' ,substr(date_idx,12,13)))
covid[covid=='-']= 0
colnames(covid) = covid[1,] ; covid = covid[-1,] ;  covid = apply(covid,2, as.numeric)
covid_view = cbind(as.Date(date_idx),as.data.frame(covid))
# View(covid_view)
covid[covid<0]= 0
row.names(covid)= date_idx
covid_raw = covid
library("accelerometry")
roll = 3
for(j in 2:ncol(covid)){
covid[roll:nrow(covid) ,j] = movingaves(covid[,j], window = roll)
}
covid = covid[-(1: (roll-1) ),]
date_idx = date_idx[c(-1,-length(date_idx))]
covid_korea = function(date_idx_for_analysis= date_idx_for_analysis ,alpha , C,restricted_infection, method,tikzedge = F){
covid_for_analysis = covid[date_idx_for_analysis,]
valid_region_idx = (colSums(covid_for_analysis)>restricted_infection)
for(j in 1:ncol(covid_for_analysis)){
covid_for_analysis[,j] = covid_for_analysis[,j]/sum(covid_for_analysis[,j])
}
Region = Region_all[valid_region_idx,]
Region$address = as.character(Region$address)
covid_for_analysis = covid_for_analysis[,valid_region_idx]
covid_for_analysis[covid_for_analysis<0] = 0
###### Proposed#############
if(sum(colnames(covid_for_analysis) == Region$address) != ncol(covid_for_analysis)){
message("correct name of regions required.");
}
X =  covid_for_analysis
# covid_new_temp  = covid_new_temp*100
DAG_covid = GSEM_Algorithm(data = X, method = method, alpha = alpha, C = C)
print(colnames(X)[DAG_covid$Ordering])
DAG = DAG_covid$DAG#DAG=Ordering_covid$DAG
DAG = as.data.frame(DAG)
colnames(DAG) = rownames(DAG) = Region$address
DAG = cbind(rownames(DAG), DAG) ; colnames(DAG)[1] = 'Address'
direction = melt(DAG,id.vars = 'Address') %>% filter(value ==1) %>% dplyr::select(c(1,2))
colnames(direction) = c('To', 'From')
direction$From = as.character(direction$From);direction$To = as.character(direction$To)
direction= direction %>% left_join(Region, by = c('To' = 'address' ))
colnames(direction)[3:4] = c('To_Y', 'To_X')
direction = direction %>% left_join(Region, by = c('From' = 'address' ))
colnames(direction)[5:6] = c('From_Y', 'From_X')
if(tikzedge == T){
temp = direction[order(direction$From),c(2,1) ]
temp2 = paste0("\\draw [edge] (",temp[,1],') -- (', temp[,2],"); \n")
for(i in 1:length(temp2)){
cat(temp2[i])
}
}
q= ggplot() +
geom_polygon(data = korea_map, aes(x = long, y = lat, group = group), fill = "#FFFFFF", colour = "#000000")+
geom_segment(data = direction, aes(x = From_X, y= From_Y, xend = To_X, yend = To_Y, color= From),
arrow = arrow(length = unit(0.2,'cm'),type = 'closed', angle = 20) , size = 0.8)+
geom_text(data= Region_all[valid_region_idx,] ,aes(x = Longitude, y= Latitude+0.1, label = address))+
coord_fixed(ratio=1)
return(q)
}
idx = (date_idx>='2020-03-10' &date_idx<='2020-05-10')
res_inf = sum(idx) / 6
alpha = 0.05
result1 = covid_korea(idx , alpha =alpha , C = 6,restricted_infection = res_inf, method = 'Cols2', tikzedge = T)
result1
idx = (date_idx>='2020-03-09' &date_idx<='2020-06-09')
res_inf = 23
alpha = 0.05
result1 = covid_korea(idx , alpha =alpha , C = 6,restricted_infection = res_inf, method = 'Cols2', tikzedge = F)
result2 = covid_korea(idx , alpha = alpha, C = 6,restricted_infection = res_inf, method = 'Cols1', tikzedge = F)
idx = (date_idx>='2020-03-09' &date_idx<='2020-06-09')
res_inf = 23
alpha = 0.05
result1 = covid_korea(idx , alpha =alpha , C = 6,restricted_infection = res_inf, method = 'Cols2', tikzedge = F)
result1
idx = (date_idx>='2020-03-04' &date_idx<='2020-06-04')
res_inf = 23
alpha = 0.05
result1 = covid_korea(idx , alpha =alpha , C = 6,restricted_infection = res_inf, method = 'Cols2', tikzedge = F)
result1
result2 = covid_korea(idx , alpha = alpha, C = 6,restricted_infection = res_inf, method = 'Cols1', tikzedge = F)
result2
covid
as.Date(rownames(covid)[1], origin = '1970-01-01')
rownames(covid)[1]
as.Date(as.numeric(rownames(covid)[1]), origin = '1970-01-01')
